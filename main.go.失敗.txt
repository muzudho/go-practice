package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/muzudho/go-practice/exercise"
)

func main() {
	arguments := make(map[string]string)

	// ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®ç™»éŒ²å…¼å–å¾—
	// ğŸ“exerciseãƒ•ã‚©ãƒ«ãƒ€ä¸‹ã®ğŸ“„ãƒ•ã‚¡ã‚¤ãƒ«åãŒç·´ç¿’åã§ã™ã€‚
	arguments["p"] = *flag.String("p", "", "Practice name is the file name under the ğŸ“exercise folder.")

	arguments["exe"] = *flag.String("exe", "", "Path to the executable file.")
	// exePath := "C:/Users/ã‚€ãšã§ã‚‡/go/src/github.com/muzudho/go-echo-next-char/go-echo-next-char.exe"

	// ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ
	flag.Parse()

	if arguments["p"] != "" {
		// ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã§ç·´ç¿’åãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã€ãã®ç·´ç¿’ã‚’å®Ÿè¡Œã—ã¾ã™
		executeCommand(arguments["p"], arguments)
		return
	}

	// ğŸ“exerciseãƒ•ã‚©ãƒ«ãƒ€ä¸‹ã®ğŸ“„ãƒ•ã‚¡ã‚¤ãƒ«åãŒç·´ç¿’åã§ã™ã€‚ä¸­ã«ã¯å¼•æ•°ãŒå¿…è¦ãªã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚ç·´ç¿’åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€€ï½œã€€ä¾‹ stringsã€€ï½œã€€ä¾‹ exitã€€ï¼š
	// ã‚’è‹±èªã§ï¼š
	fmt.Print("Please enter the command-line arguments. ï½œ e.g. `-p strings` ï½œ e.g. `exit` ï¼š")
	scanner := bufio.NewScanner(os.Stdin)

	for scanner.Scan() { // æ¨™æº–å…¥åŠ›ã‚’èª­è¾¼ã¿ã¾ã™
		commandLineArgs := scanner.Text() // 1è¡Œãšã¤ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã™

		if commandLineArgs == "exit" {
			break // "exit"ã¨å…¥åŠ›ã•ã‚ŒãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã¾ã™
		}

		commandLine := fmt.Sprintf("dammy %s", commandLineArgs)

		// ãƒ•ãƒ©ã‚°ã‚»ãƒƒãƒˆã‚’ä½œæˆï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ‚äº†ï¼‰
		fs2 := flag.NewFlagSet("custom-args", flag.ExitOnError)
		arguments2 := make(map[string]string)
		var name string
		fs2.StringVar(&name, "p", "", "Practice name is the file name under the ğŸ“exercise folder.")
		arguments2["p"] = name
		var exe string
		fs2.StringVar(&exe, "exe", "", "Path to the executable file.")
		arguments2["exe"] = exe

		// ä»»æ„ã®æ–‡å­—åˆ—ã‚’[]stringã«å¤‰æ›
		//args2 := strings.Split(commandLine, " ")
		fmt.Printf("commandLine=%s\n", commandLine)
		fmt.Printf("name=%s\n", name)
		fmt.Printf("exe=%s\n", exe)
		args2 := strings.Fields(commandLine) // è¤‡æ•°ã‚¹ãƒšãƒ¼ã‚¹ã‚‚è€ƒæ…®ã—ãŸSplit

		// ãƒ‘ãƒ¼ã‚¹å®Ÿè¡Œ
		if err := fs2.Parse(args2); err != nil {
			fmt.Println("ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", err)
			return
		}

		// // commandLine ã‚’ç©ºç™½ã§ã‚¹ãƒ—ãƒªãƒƒãƒˆã—ã€æœ€åˆã®è¦ç´ ã‚’å–å¾—ã—ã¾ã™
		// tokens := strings.Split(commandLine, " ")
		// practiceName := tokens[0] // æœ€åˆã®è¦ç´ ãŒç·´ç¿’åã§ã™

		executeCommand(arguments2["p"], arguments2)

		fmt.Print("\nç·´ç¿’åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€€ï½œã€€ä¾‹ stringsã€€ï½œã€€ä¾‹ exitã€€ï¼š")
	}
}

func executeCommand(practiceName string, arguments map[string]string) {

	fmt.Printf("ç·´ç¿’åï¼š%s\n", practiceName)

	switch practiceName {
	case "echo_stdio":
		exercise.EchoStdio()
	case "echo_proxy":
		// ```
		// echo_proxy Z:/muzudho-github.com/muzudho/go-practice/go-practice.exe
		// ```
		exercise.EchoProxy(arguments["exe"])
	case "fmt":
		exercise.Fmt()
	case "strings":
		exercise.Strings()
	}
}
